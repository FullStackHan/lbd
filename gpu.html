<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Appendix C: GPU compiler &mdash; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.9.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Tutorial: Creating an LLVM Backend for the Cpu0 Architecture" href="index.html" />
    <link rel="next" title="Todo List" href="todo.html" />
    <link rel="prev" title="Appendix B: Cpu0 document and test" href="doc.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Appendix C: GPU compiler</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="doc.html">Appendix B: Cpu0 document and test</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="todo.html">Todo List</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="appendix-c-gpu-compiler">
<span id="sec-gpu"></span><h1>Appendix C: GPU compiler<a class="headerlink" href="#appendix-c-gpu-compiler" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#d-modeling" id="id67">3D modeling</a></li>
<li><a class="reference internal" href="#d-rendering" id="id68">3D Rendering</a></li>
<li><a class="reference internal" href="#glsl-gl-shader-language" id="id69">GLSL (GL Shader Language)</a></li>
<li><a class="reference internal" href="#opengl-shader-compiler" id="id70">OpenGL Shader compiler</a></li>
<li><a class="reference internal" href="#general-purpose-gpu" id="id71">General purpose GPU</a></li>
<li><a class="reference internal" href="#vulkan-and-spir-v" id="id72">Vulkan and spir-v</a></li>
</ul>
</div>
<p>Basicly CPU compiler is SISD (Single Instruction Single Data Architecture).
The vector or multimedia instructions in CPU are small scaled of SIMD
(Single Instruction Multiple Data) for 4 or 16 element while GPU is a large
scaled of SIMD processor needing to color millions of pixels of image in few
micro seconds.
Since the 2D or 3D graphic processing providing large opportunity in parallel
data processing, GPU hardware usually composed of hundreds of cores with thousands
of functional units in each core(grid) in N-Vidia processors.
Or tens of cores with tens thousands of functional units in each core for big
cores architecture.</p>
<div class="section" id="d-modeling">
<h2><a class="toc-backref" href="#id67">3D modeling</a><a class="headerlink" href="#d-modeling" title="Permalink to this headline">¶</a></h2>
<p>Through creating 3D model with Triangles or Quads along on skin, the 3D model
is created with polygon mesh <a class="footnote-reference" href="#polygon" id="id1">[1]</a> formed by all the vertices on the first image
as follows,</p>
<div class="figure align-center" id="id58">
<span id="modeling1"></span><a class="reference internal image-reference" href="_images/modeling1.png"><img alt="_images/modeling1.png" src="_images/modeling1.png" style="width: 688.0px; height: 393.6px;" /></a>
<p class="caption"><span class="caption-number">Fig. 36 </span><span class="caption-text">Creating 3D model and texturing</span></p>
</div>
<p>After the next smooth shading <a class="footnote-reference" href="#polygon" id="id2">[1]</a>, the vertices and edge line are covered
with color (or remove edges), then model looks much more smooth <a class="footnote-reference" href="#shading" id="id3">[2]</a>.
Furthermore, after texturing (texture mapping), the model looks real more
<a class="footnote-reference" href="#texturemapping" id="id4">[3]</a>.</p>
<p>To get to know how animation for a 3D modeling, please look video here <a class="footnote-reference" href="#animation1" id="id5">[4]</a>.
In this series of video, you find the 3D modeling tools creating Java instead of
C/C++ code calling OpenGL api and shaders. It&#8217;s because Java can call OpenGL api
through a wrapper library <a class="footnote-reference" href="#joglwiki" id="id6">[5]</a>.</p>
<p>Every CAD software manufacturer such as AutoDesk and Blender has their own proprietary
format. To solve the problem of interoperability, neutral or open source formats were
invented as intermediate formats for converting between two proprietary formats.
Naturally, these formats have become hugely popular now.
Two famous examples of neutral formats are STL (with a .STL extension) and COLLADA
(with a .DAE extension). Here is the list, where the 3D file formats are marked
with their type.</p>
<ul class="simple">
<li>3D file format        Type</li>
<li>STL   Neutral</li>
<li>OBJ   ASCII variant is neutral, binary variant is proprietary</li>
<li>FBX   Proprietary</li>
<li>COLLADA       Neutral</li>
<li>3DS   Proprietary</li>
<li>IGES  Neutral</li>
<li>STEP  Neutral</li>
<li>VRML/X3D      Neutral <a class="footnote-reference" href="#dfmt" id="id7">[6]</a></li>
</ul>
</div>
<div class="section" id="d-rendering">
<h2><a class="toc-backref" href="#id68">3D Rendering</a><a class="headerlink" href="#d-rendering" title="Permalink to this headline">¶</a></h2>
<p>3D rendering is the process of converting 3D models into 2D images on a computer
<a class="footnote-reference" href="#drendering-wiki" id="id8">[7]</a>. The steps as the following Figure <a class="footnote-reference" href="#rendering" id="id9">[8]</a>.</p>
<div class="figure align-center" id="id59">
<span id="rendering-pipeline1"></span><a class="reference internal image-reference" href="_images/rendering_pipeline.png"><img alt="_images/rendering_pipeline.png" src="_images/rendering_pipeline.png" style="width: 200.8px; height: 467.2px;" /></a>
<p class="caption"><span class="caption-number">Fig. 37 </span><span class="caption-text">Diagram of the Rendering Pipeline. The blue boxes are programmable shader stages.</span></p>
</div>
<p>For 2D animation, the model is created by 2D only (1 face only), so it only can be
viewed from the same face of model. If you want to display different faces of model,
multiple 2D models need to be created and switch these 2D models for face(flame) to
face(flame) from time to time <a class="footnote-reference" href="#danimation" id="id10">[9]</a>.</p>
</div>
<div class="section" id="glsl-gl-shader-language">
<h2><a class="toc-backref" href="#id69">GLSL (GL Shader Language)</a><a class="headerlink" href="#glsl-gl-shader-language" title="Permalink to this headline">¶</a></h2>
<p>OpenGL is a standard for designing 2D/3D animation in computer graphic.
To do animation well, OpenGL provides a lots of api(functions) call for
graphic processing. The 3D model construction tools such as Maya, Blender, ...,
only need to call this api to finish the 3D to 2D projecting function in computer.
An OpenGL program looks like the following,</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">Vertex</span> <span class="n">shader</span>

<span class="cp">#version 330 core</span>
<span class="n">layout</span> <span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">aPos</span><span class="p">;</span> <span class="c1">// the position variable has attribute position 0</span>

<span class="n">out</span> <span class="n">vec4</span> <span class="n">vertexColor</span><span class="p">;</span> <span class="c1">// specify a color output to the fragment shader</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">aPos</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span> <span class="c1">// see how we directly give a vec3 to vec4&#39;s constructor</span>
    <span class="n">vertexColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span> <span class="c1">// set the output variable to a dark-red color</span>
<span class="p">}</span>
<span class="n">Fragment</span> <span class="n">shader</span>

<span class="cp">#version 330 core</span>
<span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>

<span class="n">in</span> <span class="n">vec4</span> <span class="n">vertexColor</span><span class="p">;</span> <span class="c1">// the input variable from the vertex shader (same name and same type)</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">FragColor</span> <span class="o">=</span> <span class="n">computeColorOfThisPixel</span><span class="p">(...);</span>
<span class="p">}</span>

<span class="c1">// openGl user program</span>
<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">// init window, detect user input and do corresponding animation by calling opengl api</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The last main() is programed by user clearly. Let&#8217;s explain what the first two
main() work for.
As you know, the OpenGL is a lots of api to let programmer display the 3D object
into 2D computer screen explained from book concept of computer graphic.
3D graphic model can set light and object texture by user, next calculating the
postion of each vertex and color for each pixel automatically by 3D software
and GPU, finally display the color of each pixel in computer screen.
But in order to let user/programmer add some special effect or decoration in
coordinate of each vertex or color of each pixel, OpenGL provides these two
functions to do it.
Programmer can add their converting functions then compiler translate them
into GPU instructions running on GPU processor. With these two shaders, new
features have been added to allow for increased flexibility in the rendering
pipeline at the vertex and fragment level <a class="footnote-reference" href="#shaderswiki" id="id11">[10]</a>.
Unlike the shaders example here <a class="footnote-reference" href="#shadersex" id="id12">[11]</a>, some shaders converting function
in vertex or color(Fragment shade) are more complicated according the scenes of
animation. Here is an example <a class="footnote-reference" href="#glsleffect" id="id13">[12]</a>.
In wiki shading page <a class="footnote-reference" href="#shading" id="id14">[2]</a>, Gourand and Phong shading methods make the
surface of object more smooth are achieved by glsl. Example glsl code of Gourand
and Phong shading on OpenGL api are here <a class="footnote-reference" href="#smoothshadingex" id="id15">[13]</a>.
Since the hardware of graphic card and software graphic driver can be changed,
the compiler is run on-line which means compile the shaders program when it is
run at first time.
The shaders program is C-like syntax and can be compiled in few mini-seconds,
add up this few mini-seconds of on-line compile time in running OpenGL
program is a good choice for dealing the cases of driver software or gpu
hardware changes <a class="footnote-reference" href="#onlinecompile" id="id16">[14]</a>.</p>
</div>
<div class="section" id="opengl-shader-compiler">
<h2><a class="toc-backref" href="#id70">OpenGL Shader compiler</a><a class="headerlink" href="#opengl-shader-compiler" title="Permalink to this headline">¶</a></h2>
<p>OpenGL standard is here <a class="footnote-reference" href="#openglspec" id="id17">[15]</a>. The OpenGL is for desktop computer or server
while the OpenGL ES is for embedded system <a class="footnote-reference" href="#opengleswiki" id="id18">[16]</a>. Though shaders are only
a small part of the whole OpenGL software/hardware system. It is still a big effort
to finish the compiler implementation since there are lots of api need to be
implemented.
For example, the number of texture related api is close to one hundred for code
generation since they include different api names with different operands for
each api name.
This implementation can be done by generating llvm extended intrinsic functions
from shader parser of frontend compiler, and then llvm backend convert those intrinsic
to gpu instructions as follows,</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span>version <span class="m">320</span> es
<span class="go">uniform sampler2D x;</span>
<span class="go">out vec4 FragColor;</span>

<span class="go">void main()</span>
<span class="go">{</span>
<span class="go">    FragColor = texture(x, uv_2d, bias);</span>
<span class="go">}</span>

<span class="go">...</span>
<span class="go">!1 = !{!&quot;sampler_2d&quot;}</span>
<span class="go">!2 = !{i32 SAMPLER_2D} : SAMPLER_2D is integer value for sampler2D, for example: 0x0f02</span>
<span class="go">; A named metadata.</span>
<span class="go">!x_meta = !{!1, !2}</span>

<span class="go">define void @main() #0 {</span>
<span class="go">    ...</span>
<span class="gp">    %</span><span class="nv">1</span> <span class="o">=</span> @llvm.gpu0.texture<span class="o">(</span>metadata !x_meta, %1, %2, %3<span class="o">)</span><span class="p">;</span> // %1: %sampler_2d, %2: %uv_2d, %3: %bias
<span class="go">    ...</span>
<span class="go">}</span>

<span class="go">...</span>
<span class="go">   // gpu machine code</span>
<span class="go">    sample2d_inst $1, $2, $3 // $1: %x, $2: %uv_2d, $3: %bias</span>
</pre></div>
</div>
<p>About llvm intrinsic extended function, please refer this book here <a class="footnote-reference" href="#intrinsiccpu0" id="id19">[17]</a>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">gvec4</span> <span class="nf">texture</span><span class="p">(</span><span class="n">gsampler2D</span> <span class="n">sampler</span><span class="p">,</span> <span class="n">vec2</span> <span class="n">P</span><span class="p">,</span> <span class="p">[</span><span class="kt">float</span> <span class="n">bias</span><span class="p">]);</span>
</pre></div>
</div>
<div class="figure align-center" id="id60">
<span id="sampling"></span><a class="reference internal image-reference" href="_images/sampling_diagram.png"><img alt="_images/sampling_diagram.png" src="_images/sampling_diagram.png" style="width: 489.6px; height: 330.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 38 </span><span class="caption-text">Relationships between the texturing concept <a class="footnote-reference" href="#textureobject" id="id20">[18]</a>.</span></p>
</div>
<p>The figure of &#8216;Relationships between the texturing concept&#8217; as above.
The texture object is not bound directly into the shader (where the actual
sampling takes place). Instead, it is bound to a &#8216;texture unit&#8217; whose index
is passed to the shader. So the shader reaches the texture object by going
through the texture unit. There are usually multiple texture units available
and the exact number depends on the capability of your graphis card <a class="footnote-reference" href="#textureobject" id="id21">[18]</a>.
A texture unit, also called a texture mapping unit (TMU) or a texture processing
unit (TPU), is a hardware component in a GPU that does sampling.
The argument sampler in texture function as above is sampler_2d index from
&#8216;teuxture unit&#8217; for texture object <a class="footnote-reference" href="#textureobject" id="id22">[18]</a>.</p>
<p>&#8216;sampler uniform variable&#8217;:</p>
<p>There is a group of special uniform variables for that, according to the texture
target: &#8216;sampler1D&#8217;, &#8216;sampler2D&#8217;, &#8216;sampler3D&#8217;, &#8216;samplerCube&#8217;, etc.
You can create as many &#8216;sampler uniform variables&#8217; as you want and assign the
value of a texture unit to each one from the application.
Whenever you call a sampling function on a &#8216;sampler uniform variable&#8217; the
corresponding texture unit (and texture object) will be used <a class="footnote-reference" href="#textureobject" id="id23">[18]</a>.</p>
<div class="figure align-center" id="id61">
<span id="sampling-binding"></span><img alt="_images/sampling_diagram_binding.png" src="_images/sampling_diagram_binding.png" />
<p class="caption"><span class="caption-number">Fig. 39 </span><span class="caption-text">Binding sampler variables <a class="footnote-reference" href="#tpu" id="id24">[19]</a>.</span></p>
</div>
<p>As Figure: Binding sampler variables, the Java OpenGL wrapper api
gl.bindTexture binding &#8216;Texture Object&#8217; to &#8216;Texture Unit&#8217;.
The gl.getUniformLocation and gl.uniform1i associate &#8216;Texture Unit&#8217; to
&#8216;sampler uniform variables&#8217;.</p>
<p>The gl.uniform1i(xLoc, 1) where 1 is
&#8216;Texture Unit 1&#8217;, 2 is &#8216;Texture Unit 2&#8217;, ..., etc <a class="footnote-reference" href="#tpu" id="id25">[19]</a>.</p>
<p>The following figure depicts how driver read metadata from compiled glsl obj,
OpenGL api associate &#8216;Sample Variable&#8217; and gpu executing texture instruction.</p>
<div class="figure align-center" id="id62">
<span id="driversamplertable"></span><img alt="_images/driverSamplerTable.png" src="_images/driverSamplerTable.png" />
<p class="caption"><span class="caption-number">Fig. 40 </span><span class="caption-text">Associating Sampler Variables and gpu executing texture instruction</span></p>
</div>
<p>Explaining the detail steps for figure above as the following.</p>
<p>1. In order to let the &#8216;texture unit&#8217; binding by driver, frontend compiler must
pass the metadata of &#8216;sampler uniform variable&#8217; (sampler_2d_var in this example)
<a class="footnote-reference" href="#samplervar" id="id26">[22]</a> to backend, and backend must
allocate the metadata of &#8216;sampler uniform variable&#8217; in the compiled
binary file <a class="footnote-reference" href="#metadata" id="id27">[20]</a>.</p>
<p>2. After gpu driver executing glsl on-line compiling,
driver read this metadata from compiled binary file and maintain a
table of {name, SamplerType} for each &#8216;sampler uniform variable&#8217;.</p>
<ol class="arabic simple" start="3">
<li>Api,</li>
</ol>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">xLoc</span> <span class="o">=</span> <span class="n">gl</span><span class="p">.</span><span class="n">getUniformLocation</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="s">&quot;x&quot;</span><span class="p">);</span> <span class="c1">// prog: glsl program, xLoc</span>
</pre></div>
</div>
<p>will get the location from the table for &#8216;sampler uniform variable&#8217; x that
driver created and set the memory address xSlot to xLoc.</p>
<p>SAMPLER_2D: is integer value for Sampler2D type.</p>
<ol class="arabic simple" start="4">
<li>Api,</li>
</ol>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">gl</span><span class="p">.</span><span class="n">uniform1i</span><span class="p">(</span> <span class="n">xLoc</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
</pre></div>
</div>
<p>will binding xLoc of &#8216;sampler uniform variable&#8217; x to
&#8216;Texture Unit 1&#8217; by writing 1 to the glsl binary metadata location of
&#8216;sampler uniform variable&#8217; x as follows,</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">{xLoc, 1} : 1 is &#39;Texture Unit 1&#39;, xLoc is the location(memory address) of &#39;sampler uniform variable&#39; x</span>
</pre></div>
</div>
<p>This api will set the descriptor register of gpu with this {xLoc, 1}
information <a class="footnote-reference" href="#descriptorreg" id="id28">[23]</a>.</p>
<ol class="arabic simple" start="5">
<li>When executing the texture instructions from glsl binary file on gpu,</li>
</ol>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">// gpu machine code</span>
<span class="go">load $1, &amp;xSlot;</span>
<span class="go">sample2d_inst $1, $2, $3 // $1: %x, $2: %uv_2d, $3: %bias</span>
</pre></div>
</div>
<p>the corresponding &#8216;Texture Unit 1&#8217; on gpu will be executing through descriptor
register of gpu {xLoc, 1} in this example since memory address xSlot includes the
value of xLoc. And &#8216;Texture Unit 1&#8217; is triggered.</p>
<p>For instance, Nvidia texture instruction as follow,</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">tex.3d.v4.s32.s32  {r1,r2,r3,r4}, [tex_a, {f1,f2,f3,f4}];</span>
</pre></div>
</div>
<p>Above 3d texture instruction load tex_a texture memory address for
&#8216;sampler uniform variable&#8217; x at at coordinates (x,y,z)=(f1,f2,f3) into GPRs
(r1,r2,r3,r4)=(R,G,B,A). The f4 is skipped for 3D texture.
And fragment shader can calculate the color of this pixel with this color of
texture value <a class="footnote-reference" href="#ptxtex" id="id29">[21]</a>. For instance, 1d texture instruction as follows,</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">tex.1d.v4.s32.f32  {r1,r2,r3,r4}, [tex_a, {f1}];</span>
</pre></div>
</div>
<p>Since &#8216;Texture Unit&#8217; is limited hardware accelerator on gpu, OpenGL
providing api to user program for binding &#8216;Texture Unit&#8217; to &#8216;Sampler Variables&#8217;
to doing load balance in using the &#8216;Texture Unit&#8217;. With this mechanism, programmer
can do load balance through OpenGL api without recompiling glsl.
The glsl on-line compiling only be triggered at first time of running program.
It is kept in cache and is executing directly after first time of compiling.
Fast texture sampling is one of the key requirements for good GPU performance
<a class="footnote-reference" href="#tpu" id="id30">[19]</a>.</p>
<p>In addition to binding api for texture, OpenGL providing glTexParameteri api to
do Texture Wrapping <a class="footnote-reference" href="#texturewrapper" id="id31">[24]</a>.
And the texture instruction of some gpu including S# T# value in operands.
Same with associating &#8216;Sampler Variables&#8217; to &#8216;Texture Unit&#8217;, S# and T# value are
location of memory associating to Texture Wrapping descriptor register.
Allowing user program change Wrapping option without re-compiling glsl.</p>
<p>Even llvm intrinsic extended function providing an easy way to do code
generation through llvm td (Target Description) file written,
GPU backend compiler is still a little complex than CPU backend.
(When counting in frontend compier such as clang or other toolchain such
as linker and gdb/lldb, of course, CPU compiler is much much complex than
GPU compiler.)</p>
<p>Here is the software stack of 3D graphic system for OpenGL in linux <a class="footnote-reference" href="#mesawiki" id="id32">[25]</a>.
And mesa open source website is here <a class="footnote-reference" href="#mesa" id="id33">[26]</a>.</p>
</div>
<div class="section" id="general-purpose-gpu">
<h2><a class="toc-backref" href="#id71">General purpose GPU</a><a class="headerlink" href="#general-purpose-gpu" title="Permalink to this headline">¶</a></h2>
<p>Since GLSL shaders provide a general way for writing C code in them, if applying
a software frame work instead of OpenGL api, then the system can run some data
parallel computation on GPU for speeding up and even get CPU and GPU executing
simultaneously. Or Any language that allows the code running on the CPU to poll
a GPU shader for return values, can create a GPGPU framework <a class="footnote-reference" href="#gpgpuwiki" id="id34">[27]</a>.
The leading GPGPU framdwork CUDA, and architecture of Nvidia gpu as the following
figures.</p>
<div class="figure align-center" id="id63">
<span id="grid"></span><a class="reference internal image-reference" href="_images/grid.png"><img alt="_images/grid.png" src="_images/grid.png" style="width: 560.0px; height: 688.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 41 </span><span class="caption-text">core(grid) in Nvidia gpu (figure from book <a class="footnote-reference" href="#quantitative-grid" id="id35">[28]</a>)</span></p>
</div>
<div class="figure align-center" id="id64">
<span id="simd-processors"></span><a class="reference internal image-reference" href="_images/SIMD-processors.png"><img alt="_images/SIMD-processors.png" src="_images/SIMD-processors.png" style="width: 552.0px; height: 547.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 42 </span><span class="caption-text">SIMD processors (figure from book <a class="footnote-reference" href="#quantitative-simd-processors" id="id36">[29]</a>)</span></p>
</div>
<div class="figure align-center" id="id65">
<span id="threadslanes"></span><a class="reference internal image-reference" href="_images/threads-lanes.png"><img alt="_images/threads-lanes.png" src="_images/threads-lanes.png" style="width: 636.0px; height: 581.0px;" /></a>
<p class="caption"><span class="caption-number">Fig. 43 </span><span class="caption-text">threads and lanes in gpu (figure from book <a class="footnote-reference" href="#quantitative-threads-lanes" id="id37">[30]</a>)</span></p>
</div>
<div class="figure align-center" id="id66">
<span id="gpu-mem"></span><a class="reference internal image-reference" href="_images/memory.png"><img alt="_images/memory.png" src="_images/memory.png" style="width: 543.2px; height: 506.4px;" /></a>
<p class="caption"><span class="caption-number">Fig. 44 </span><span class="caption-text">core(grid) in Nvidia gpu (figure from book <a class="footnote-reference" href="#quantitative-gpu-mem" id="id38">[31]</a>)</span></p>
</div>
<p>The following is a CUDA example to run large data in array on GPU <a class="footnote-reference" href="#cudaex" id="id39">[38]</a>
as follows,</p>
<div class="highlight-c++"><div class="highlight"><pre><span></span><span class="n">__global__</span>
<span class="kt">void</span> <span class="nf">saxpy</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="o">*</span><span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span><span class="o">*</span><span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
  <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">d_x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>
  <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">d_y</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>
  <span class="p">...</span>
  <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">d_y</span><span class="p">,</span> <span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span> <span class="n">cudaMemcpyDeviceToHost</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the programming example in <a class="reference internal" href="#grid"><span class="std std-numref">Fig. 41</span></a>,</p>
<ul class="simple">
<li>Grid is Vectorizable Loop <a class="footnote-reference" href="#quantitative-gpu-griddef" id="id40">[32]</a>.</li>
<li>Each multithreaded SIMD Processor is assigned 512 elements of the vectors to work on.
As <a class="reference internal" href="#grid"><span class="std std-numref">Fig. 41</span></a>: The hardware Thread Block Scheduler assigns Thread Blocks to
multithreaded SIMD Processors. Thread Block &lt;-&gt; SIMD Processor.</li>
<li>SIMD Processors are full processors with separate PCs and are programmed using
threads <a class="footnote-reference" href="#quantitative-gpu-threadblock" id="id41">[33]</a>.
As <a class="reference internal" href="#simd-processors"><span class="std std-numref">Fig. 42</span></a>, it assigns 16 Thread blocks to 16 SIMD Processors.</li>
<li>As <a class="reference internal" href="#grid"><span class="std std-numref">Fig. 41</span></a>,
the maximum number of SIMD Threads that can execute simultaneously per Thread Block
(SIMD Processor) is 32 for the later Fermi-generation GPUs.
Each SIMD Thread has 32 elements run on <a class="reference internal" href="#threadslanes"><span class="std std-numref">Fig. 43</span></a>
16 SIMD lanes (number of pipelines and each pipeline has it&#8217;s own functional unit
as in vector processor). So it takes 2 clock cycles to complete <a class="footnote-reference" href="#lanes" id="id42">[34]</a>.</li>
</ul>
<p>And from saxpy() code above,</p>
<ul class="simple">
<li>blockIdx is index of ThreadBlock</li>
<li>threadIdx is index of SIMD Thread</li>
<li>blockDim is the number of total Thread Blocks in a Grid</li>
</ul>
<p>The main() run on CPU while the saxpy() run on GPU. Through
cudaMemcpyHostToDevice and cudaMemcpyDeviceToHost, CPU can pass data in x and y
array to GPU and get result from GPU to y array.
Since both of these memory transfers trigger the DMA functions without CPU operation,
it maybe speed up by running both CPU/GPU with their data in their own cache.
After DMA memcpy from cpu&#8217;s memory to gpu&#8217;s, gpu operate the &#8220;y[i] = a*x[i] +y[i];&#8221;
instruction with one Grid. Furthermore liking vector processor, gpu provides
Vector Mask Registers to Handling IF Statements in Vector Loops as the following
code <a class="footnote-reference" href="#vmr" id="id43">[35]</a>,</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>for(i=0;i&lt;64; i=i+1)
  if (X[i] != 0)
    X[i] = X[i] – Y[i];
</pre></div>
</div>
<div class="code asm highlight-default"><div class="highlight"><pre><span></span><span class="n">LV</span> <span class="n">V1</span><span class="p">,</span><span class="n">Rx</span>         <span class="p">;</span><span class="n">load</span> <span class="n">vector</span> <span class="n">X</span> <span class="n">into</span> <span class="n">V1</span>
<span class="n">LV</span> <span class="n">V2</span><span class="p">,</span><span class="n">Ry</span>         <span class="p">;</span><span class="n">load</span> <span class="n">vector</span> <span class="n">Y</span>
<span class="n">L</span><span class="o">.</span><span class="n">D</span> <span class="n">F0</span><span class="p">,</span><span class="c1">#0        ;load FP zero into F0</span>
<span class="n">SNEVS</span><span class="o">.</span><span class="n">D</span> <span class="n">V1</span><span class="p">,</span><span class="n">F0</span>    <span class="p">;</span><span class="n">sets</span> <span class="n">VM</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="n">to</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">V1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">!=</span><span class="n">F0</span>
<span class="n">SUBVV</span><span class="o">.</span><span class="n">D</span> <span class="n">V1</span><span class="p">,</span><span class="n">V1</span><span class="p">,</span><span class="n">V2</span> <span class="p">;</span><span class="n">subtract</span> <span class="n">under</span> <span class="n">vector</span> <span class="n">mask</span>
<span class="n">SV</span> <span class="n">V1</span><span class="p">,</span><span class="n">Rx</span>         <span class="p">;</span><span class="n">store</span> <span class="n">the</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">X</span>
</pre></div>
</div>
<p>Though gpu has smaller L1 cache than cpu for each core,
the DMA memcpy map the data in cpu memory to gpu memory to each l1 cache of core.
Or gpu provides operations scatter and gather to access DRAM data for stream
processing <a class="footnote-reference" href="#quantitative-gpu-sparse-matrix" id="id44">[36]</a> <a class="footnote-reference" href="#gpgpuwiki" id="id45">[27]</a> <a class="footnote-reference" href="#shadingl1" id="id46">[37]</a>.</p>
<p>When the GPU function is dense computation in array such as MPEG4 encoder or
deep learning for tuning weights, it mays get much speed up <a class="footnote-reference" href="#mpeg4speedup" id="id47">[39]</a>.
But when GPU function is matrix addition and CPU will idle for waiting
GPU&#8217;s result. It mays slow down than doing matrix addition by CPU only.
Arithmetic intensity is defined as the number of operations performed per word of
memory transferred. It is important for GPGPU applications to have high arithmetic
intensity else the memory access latency will limit computational speedup
<a class="footnote-reference" href="#gpgpuwiki" id="id48">[27]</a>.</p>
<p>Wiki here <a class="footnote-reference" href="#gpuspeedup" id="id49">[40]</a> includes speedup applications for gpu as follows:</p>
<p>General Purpose Computing on GPU, has found its way into fields as diverse as
machine learning, oil exploration, scientific image processing, linear algebra,
statistics, 3D reconstruction and even stock options pricing determination.
And section &#8220;GPU accelerated video decoding and encoding&#8221; for video compressing
more.</p>
</div>
<div class="section" id="vulkan-and-spir-v">
<h2><a class="toc-backref" href="#id72">Vulkan and spir-v</a><a class="headerlink" href="#vulkan-and-spir-v" title="Permalink to this headline">¶</a></h2>
<p>Though OpenGL api existed in higher level with many advantages from sections
above, sometimes it cannot compete in efficience with direct3D providing
lower levels api for operating memory by user program <a class="footnote-reference" href="#vulkanapiwiki" id="id50">[41]</a>.
Vulkan api is lower level C/C++ api to fill the gap allowing user program to
do these things in OpenGL to compete against Microsoft direct3D.
Here is an example <a class="footnote-reference" href="#vulkanex" id="id51">[42]</a>. Meanwhile glsl is C-like language. The vulkan
infrastructure provides tool to compile glsl into an Intermediate Representation
form (IR) called spir-v <a class="footnote-reference" href="#spirvtoolchain" id="id52">[43]</a>.
As a result, it saves part of compiling time from glsl to gpu instructions on-line
since spir-v is IR of level closing to llvm IR <a class="footnote-reference" href="#spirvwiki" id="id53">[44]</a>.
In addition, vulkan api reduces gpu drivers efforts in optimization and code
generation <a class="footnote-reference" href="#vulkanapiwiki" id="id54">[41]</a>. These standards provide user programmer option in
using vulkan/spir-v or OpenGL/glsl, and allow them to pre-compile glsl into spir-v
to saving part of on-line compiling time.</p>
<p>With vulkan and spir-v standard, the gpu can be used in OpenCL for Parallel
Programming of Heterogeneous Systems <a class="footnote-reference" href="#opencl" id="id55">[45]</a> <a class="footnote-reference" href="#computekernelwiki" id="id56">[46]</a>.
And once OpenCL glows into a popular standard and more languages and frame
work will support OpenCL language, GPU will take more jobs from CPU
<a class="footnote-reference" href="#opencl-wiki-supported-lang" id="id57">[47]</a>.</p>
<p>Now, you find llvm IR expanding from cpu to gpu becoming influentially more and
more. And actually, llvm IR expanding from version 3.1 to now as I feel.</p>
<table class="docutils footnote" frame="void" id="polygon" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> <a class="reference external" href="https://www.quora.com/Which-one-is-better-for-3D-modeling-Quads-or-Tris">https://www.quora.com/Which-one-is-better-for-3D-modeling-Quads-or-Tris</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="shading" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id14">2</a>)</em> <a class="reference external" href="https://en.wikipedia.org/wiki/Shading">https://en.wikipedia.org/wiki/Shading</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="texturemapping" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td><a class="reference external" href="https://en.wikipedia.org/wiki/Texture_mapping">https://en.wikipedia.org/wiki/Texture_mapping</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="animation1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[4]</a></td><td><a class="reference external" href="https://www.youtube.com/watch?v=f3Cr8Yx3GGA">https://www.youtube.com/watch?v=f3Cr8Yx3GGA</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="joglwiki" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[5]</a></td><td><a class="reference external" href="https://en.wikipedia.org/wiki/Java_OpenGL">https://en.wikipedia.org/wiki/Java_OpenGL</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="dfmt" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[6]</a></td><td><a class="reference external" href="https://all3dp.com/3d-file-format-3d-files-3d-printer-3d-cad-vrml-stl-obj/">https://all3dp.com/3d-file-format-3d-files-3d-printer-3d-cad-vrml-stl-obj/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="drendering-wiki" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[7]</a></td><td><a class="reference external" href="https://en.wikipedia.org/wiki/3D_rendering">https://en.wikipedia.org/wiki/3D_rendering</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="rendering" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[8]</a></td><td><a class="reference external" href="https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview">https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="danimation" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[9]</a></td><td><a class="reference external" href="https://tw.video.search.yahoo.com/search/video?fr=yfp-search-sb&amp;p=2d+animation#id=12&amp;vid=46be09edf57b960ae79e9cd077eea1ea&amp;action=view">https://tw.video.search.yahoo.com/search/video?fr=yfp-search-sb&amp;p=2d+animation#id=12&amp;vid=46be09edf57b960ae79e9cd077eea1ea&amp;action=view</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="shaderswiki" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[10]</a></td><td><a class="reference external" href="https://en.m.wikipedia.org/wiki/OpenGL_Shading_Language">https://en.m.wikipedia.org/wiki/OpenGL_Shading_Language</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="shadersex" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[11]</a></td><td><a class="reference external" href="https://learnopengl.com/Getting-started/Shaders">https://learnopengl.com/Getting-started/Shaders</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="glsleffect" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[12]</a></td><td><a class="reference external" href="https://www.youtube.com/watch?v=LyoSSoYyfVU">https://www.youtube.com/watch?v=LyoSSoYyfVU</a> at 5:25 from beginning: combine different textures.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="smoothshadingex" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[13]</a></td><td><a class="reference external" href="https://github.com/ruange/Gouraud-Shading-and-Phong-Shading">https://github.com/ruange/Gouraud-Shading-and-Phong-Shading</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="onlinecompile" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[14]</a></td><td><a class="reference external" href="https://community.khronos.org/t/offline-glsl-compilation/61784">https://community.khronos.org/t/offline-glsl-compilation/61784</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="openglspec" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[15]</a></td><td><a class="reference external" href="https://www.khronos.org/registry/OpenGL-Refpages/">https://www.khronos.org/registry/OpenGL-Refpages/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="opengleswiki" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[16]</a></td><td><a class="reference external" href="https://en.wikipedia.org/wiki/OpenGL_ES">https://en.wikipedia.org/wiki/OpenGL_ES</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="intrinsiccpu0" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[17]</a></td><td><a class="reference external" href="http://jonathan2251.github.io/lbd/funccall.html#add-specific-backend-intrinsic-function">http://jonathan2251.github.io/lbd/funccall.html#add-specific-backend-intrinsic-function</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="textureobject" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[18]</td><td><em>(<a class="fn-backref" href="#id20">1</a>, <a class="fn-backref" href="#id21">2</a>, <a class="fn-backref" href="#id22">3</a>, <a class="fn-backref" href="#id23">4</a>)</em> <a class="reference external" href="http://ogldev.atspace.co.uk/www/tutorial16/tutorial16.html">http://ogldev.atspace.co.uk/www/tutorial16/tutorial16.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="tpu" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[19]</td><td><em>(<a class="fn-backref" href="#id24">1</a>, <a class="fn-backref" href="#id25">2</a>, <a class="fn-backref" href="#id30">3</a>)</em> <a class="reference external" href="http://math.hws.edu/graphicsbook/c6/s4.html">http://math.hws.edu/graphicsbook/c6/s4.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="metadata" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id27">[20]</a></td><td>This can be done by llvm metadata. <a class="reference external" href="http://llvm.org/docs/LangRef.html#namedmetadatastructure">http://llvm.org/docs/LangRef.html#namedmetadatastructure</a> <a class="reference external" href="http://llvm.org/docs/LangRef.html#metadata">http://llvm.org/docs/LangRef.html#metadata</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="ptxtex" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id29">[21]</a></td><td>page 84: tex instruction, p24: texture memory <a class="reference external" href="https://www.nvidia.com/content/CUDA-ptx_isa_1.4.pdf">https://www.nvidia.com/content/CUDA-ptx_isa_1.4.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="samplervar" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id26">[22]</a></td><td>The type of &#8216;sampler uniform variable&#8217; called &#8220;sampler variables&#8221;. <a class="reference external" href="http://math.hws.edu/graphicsbook/c6/s4.html">http://math.hws.edu/graphicsbook/c6/s4.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="descriptorreg" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id28">[23]</a></td><td>When performing a texture fetch, the addresses to read pixel data from are computed by reading the GPRs that hold the texture descriptor and the GPRs that hold the texture coordinates. It&#8217;s mostly just general purpose memory fetching. <a class="reference external" href="https://www.gamedev.net/forums/topic/681503-texture-units/">https://www.gamedev.net/forums/topic/681503-texture-units/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="texturewrapper" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id31">[24]</a></td><td><a class="reference external" href="https://learnopengl.com/Getting-started/Textures">https://learnopengl.com/Getting-started/Textures</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="mesawiki" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id32">[25]</a></td><td><a class="reference external" href="https://en.wikipedia.org/wiki/Mesa_(computer_graphics">https://en.wikipedia.org/wiki/Mesa_(computer_graphics</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="mesa" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id33">[26]</a></td><td><a class="reference external" href="https://www.mesa3d.org/">https://www.mesa3d.org/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="gpgpuwiki" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[27]</td><td><em>(<a class="fn-backref" href="#id34">1</a>, <a class="fn-backref" href="#id45">2</a>, <a class="fn-backref" href="#id48">3</a>)</em> <a class="reference external" href="https://en.wikipedia.org/wiki/General-purpose_computing_on_graphics_processing_units">https://en.wikipedia.org/wiki/General-purpose_computing_on_graphics_processing_units</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="quantitative-grid" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id35">[28]</a></td><td>Book Figure 4.13 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="quantitative-simd-processors" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id36">[29]</a></td><td>Book Figure 4.15 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="quantitative-threads-lanes" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id37">[30]</a></td><td>The SIMD Thread Scheduler includes a scoreboard that lets it know which threads of SIMD instructions are ready to run, and then it sends them off to a dispatch unit to be run on the multithreaded SIMD Processor. It is identical to a hardware thread scheduler in a traditional multithreaded processor (see Chapter 3), just that it is scheduling threads of SIMD instructions. Thus, GPU hardware has two levels of hardware schedulers: (1) the Thread Block Scheduler that assigns Thread Blocks (bodies of vectorized loops) to multi- threaded SIMD Processors, which ensures that thread blocks are assigned to the processors whose local memories have the corresponding data, and (2) the SIMD Thread Scheduler within a SIMD Processor, which schedules when threads of SIMD instructions should run.
Book Figure 4.14 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="quantitative-gpu-mem" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id38">[31]</a></td><td>Book Figure 4.17 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="quantitative-gpu-griddef" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id40">[32]</a></td><td>Book Figure 4.12 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="quantitative-gpu-threadblock" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id41">[33]</a></td><td>search these words from section 4.4 of A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="lanes" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id42">[34]</a></td><td>&#8220;With Fermi, each 32-wide thread of SIMD instructions is mapped to 16 physical SIMD Lanes, so each SIMD instruction in a thread of SIMD instructions takes two clock cycles to complete&#8221; search these words from Page 296 of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="vmr" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id43">[35]</a></td><td>subsection Vector Mask Registers: Handling IF Statements in Vector Loops of Computer Architecture: A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="quantitative-gpu-sparse-matrix" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id44">[36]</a></td><td>Reference &#8220;Gather-Scatter: Handling Sparse Matrices in Vector Architectures&#8221;: section 4.2 Vector Architecture of A Quantitative Approach 5th edition (The
Morgan Kaufmann Series in Computer Architecture and Design)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="shadingl1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id46">[37]</a></td><td>The whole chip shares a single L2 cache, but the different units will have individual L1 caches. <a class="reference external" href="https://computergraphics.stackexchange.com/questions/355/how-does-texture-cache-work-considering-multiple-shader-units">https://computergraphics.stackexchange.com/questions/355/how-does-texture-cache-work-considering-multiple-shader-units</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="cudaex" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id39">[38]</a></td><td><a class="reference external" href="https://devblogs.nvidia.com/easy-introduction-cuda-c-and-c/">https://devblogs.nvidia.com/easy-introduction-cuda-c-and-c/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="mpeg4speedup" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id47">[39]</a></td><td><a class="reference external" href="https://www.manchestervideo.com/2016/06/11/speed-h-264-encoding-budget-gpu/">https://www.manchestervideo.com/2016/06/11/speed-h-264-encoding-budget-gpu/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="gpuspeedup" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id49">[40]</a></td><td><a class="reference external" href="https://en.wikipedia.org/wiki/Graphics_processing_unit">https://en.wikipedia.org/wiki/Graphics_processing_unit</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="vulkanapiwiki" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[41]</td><td><em>(<a class="fn-backref" href="#id50">1</a>, <a class="fn-backref" href="#id54">2</a>)</em> Vulkan offers lower overhead, more direct control over the GPU, and lower CPU usage... By allowing shader pre-compilation, application initialization speed is improved... A Vulkan driver only needs to do GPU specific optimization and code generation, resulting in easier driver maintenance... <a class="reference external" href="https://en.wikipedia.org/wiki/Vulkan_(API">https://en.wikipedia.org/wiki/Vulkan_(API</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="vulkanex" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id51">[42]</a></td><td><a class="reference external" href="https://github.com/SaschaWillems/Vulkan/blob/master/examples/triangle/triangle.cpp">https://github.com/SaschaWillems/Vulkan/blob/master/examples/triangle/triangle.cpp</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="spirvtoolchain" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id52">[43]</a></td><td>glslangValidator is the tool used to compile GLSL shaders into SPIR-V, Vulkan&#8217;s shader format. <a class="reference external" href="https://vulkan.lunarg.com/doc/view/1.0.39.1/windows/spirv_toolchain.html">https://vulkan.lunarg.com/doc/view/1.0.39.1/windows/spirv_toolchain.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="spirvwiki" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id53">[44]</a></td><td>SPIR 2.0: LLVM IR version 3.4. SPIR-V 1.X: 100% Khronos defined Round-trip lossless conversion to llvm.  <a class="reference external" href="https://en.wikipedia.org/wiki/Standard_Portable_Intermediate_Representation">https://en.wikipedia.org/wiki/Standard_Portable_Intermediate_Representation</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="opencl" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id55">[45]</a></td><td><a class="reference external" href="https://www.khronos.org/opencl/">https://www.khronos.org/opencl/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="computekernelwiki" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id56">[46]</a></td><td><a class="reference external" href="https://en.wikipedia.org/wiki/Compute_kernel">https://en.wikipedia.org/wiki/Compute_kernel</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="opencl-wiki-supported-lang" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id57">[47]</a></td><td>The OpenCL standard defines host APIs for C and C++; third-party APIs exist for other programming languages and platforms such as Python,[14] Java, Perl[15] and .NET.[11]:15 <a class="reference external" href="https://en.wikipedia.org/wiki/OpenCL">https://en.wikipedia.org/wiki/OpenCL</a></td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="doc.html">Appendix B: Cpu0 document and test</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="todo.html">Todo List</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, Chen Chung-Shu.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.4.
    </div>
  </body>
</html>